# More Cookies
### Author: madStacks
### Web Exploitation: 90 points

I forgot Cookies can Be modified Client-side, so now I decided to encrypt them! http://mercury.picoctf.net:43275/

---

Visiting the site, we see that we can only use the search endpoint if we are admin. Checking the cookies we see a base64 string under the cookie `auth_name`. Decoding it from base64 gives another base64 string, which in turn gives random bytes. These bytes are probably encrypted. Since the description has the words "Cookies", "Be" and "Client" capitalized, the encryption scheme is likely a block cipher scheme using CBC, or Cipher Block Chaining.

![](https://user-images.githubusercontent.com/49169930/114278501-24054480-99fe-11eb-80b7-bb308933e1f0.png)

When decrypting a block cipher using CBC, the current block of ciphertext is decrypted using the scheme, then XORed with the previous block of ciphertext to get the current block of plaintext. How can we use this to our advantage?

Assuming our cookie structure looks something like this:

`{random text..., "admin":0, random text...}`

We can take advantage of CBC to change `"admin"` to be `1` by manipulating the byte in the previous block. Let `b` be the byte in the previous block with the same index, `i`, as our target byte. 

```
dec(encrypted_admin_block[i]) ^ b = 0x30
dec(encrypted_admin_block[i]) ^ b ^ 0x1 = 0x30 ^ 0x1
dec(encrypted_admin_block[i]) ^ b ^ 0x1 = 0x31
```

Perfect. All we need to do is return the same cookie, but replacing `b` with `b ^ 0x1` and hope that tampering with the previous block doesn't break something. We don't know the position of `b` but we can just bruteforce every position, hoping we get the flag.

[Here](morecookies.py) is my solve script.

flag: `picoCTF{cO0ki3s_yum_1b75d657}`
